
// Verbum

// Todos arquivos dentro de um pacote instalado, ou de diret√≥rio espec√≠fico.
use 'std:*';
use 'path/*';

// Importa√ß√µes √∫nicas.
use 'std:io';
use 'std:io/file';
use 'test';
use 'path/path/test';

// Importa√ß√µes m√∫ltiplas (dentro de um √∫nico m√≥dulo ou diret√≥rio).
use 'std:<io, net, os, string>';
use 'path/<file1, file2, file3>';

// Importa√ß√µes m√∫ltiplas em uma √∫nica linha.
use 'std:<io,net>', 'path/test', 'util';
use 'path2/*', 'mysql:*', 'json:unicode';


// Para valores comuns o tipo √© inferido automaticamente.
// Os caracteres e strings s√£o UNICODE.
// √â aceito aspas simples ou duplas para as strings e caracteres.
var variable :int       = 31337;
var variable :int       = -1337;
var variable :float     = 0.1337;
var variable :double    = 3.1337;
var variable :double    = -1.337;
var variable :bool      = true;
var variable :char      = '‚ô•';
var variable :string    = 'Verbum üòç';
var variavle :stream    = file.open('archive.bin');

// O UNICODE √© aceito no uso comum da linguagem.
var Œª = "Verbum ‚ô•";
var œÄ = 3.14;

// String de m√∫ltiplass linhas.
var variable = "
    In princ√≠pio
    erat Verbum!
";
// Constantes aceitam apenas valores comuns.
var variable :const     = 31337;
var variable :const     = 3.1337;
var variable :const     = true;
var variable :const     = "Verbum üòç";

// Indexados, com acesso via n√∫mero do index.
var variable :array = [ 3, 1, 3, 3, 7 ];
var variable :array = [ 'V', '‚ô•', true, "Verbum üòç" ];
var variable :array = [ 10 :int, 20 :int, 30.3, 40 :float, true, n ];
var variable :array = [ ];

var variable :array = [
    1, 2, 3,
    [
        'a', 'b', 'c',
        "Verbum", "Divinus",
        3.1337
    ],
    [
        a, b, c,
        10 :int, 20 :int, 30 :float
    ]
];

// Associativos, com acesso via chave/hash.
var variable :array = {
    items: [
        { name: "Verbum"  },
        { name: "Divinus" },
        {
            values: [
                10, 20, 30:float, { name: "Member" }
            ]
        },
        31337
    ]
};

var variable = {
    value: 1.337 :double
};


// Outros exemplos.
var variable :array = [
    { name: "Verbum" },
    10, 20, 30,
    {
        values: [
            31337 :double, { name: "Divinus" }
        ] 
    }
];


// Opera√ß√µes como valores.
// Obs: caso n√£o seja especificado tipo na vari√°vel, em opera√ß√µes aritm√©ticas
// o valor final √© automaticamente convertido para inteiro. Caso queira converter
// o valor final para outro, √© obrigat√≥rio especificar o tipo da vari√°vel, ex.: :float
var variable = (10 + (variable++) + (3.14 * 3) / --abc);

var variable = [
    1, 2, 3,
    (10 + ( 20 * 3 ) / 4),
    'str 1', "str 2"
];

var variable :array = [
    { name:  "Verbum" },
    {
        value: 'Divino',
        operation:  (3 + ( 3 ) + 3)
    }
];

var variable = [
    1, 2, 3,
    (10 + 20),
    'str 1', "str 2"
];

// Fun√ß√£o an√¥nima como valor em vari√°vel.
var variable = (fn (a :int) -> int {
    ret a + 10;
});

// Fun√ß√£o an√¥nima com array indexado.
var variable = [
    31337,
    (fn (a :int, b :int) -> int {
        ret a + b;   
    })
];


// Fun√ß√£o an√¥nima com array associativo.
var variable = {
    identifier : 'onclick',
    callback   : (fn (a :int, b :int) -> int {
        ret a + b;   
    })
};

var value = variable.callback(10, 20);


// Tipos de valores recebidos em vari√°veis.
var variable = true;
var variable = 'a';
var variable = 'string 1';
var variable = "string 2";
var variable = 123;
var variable = 3.14;
var variable = 0.12345;
var variable = [ 1, 2, 3 ];
var variable = { values: [ 1, 2, 3 ] };
var variable = anotherVariable;
var variable = functionName(10, 20, 30);
var variable = obj::functionName(10, 20, 30);
var variable = obj.functionName(10, 20, 30);

var variable = (10 + 20);
var variable = (variable * 10 + 20 / 30);
if (expression) 
    print("value 1");
elif (expression)
    print("value 2");
else
    print("value 3");
// Comum.
for (var a = 0; a<100; a++)
    print("Hello world\n");

for (var a = 0; ; a++) {
    if (a >= 100)
        break;
}

for (var a = 0; ; a++) {
    if (a < 100)
        next;
}

// Equivalente ao while.
for (a < 10)
    print("a: {}\n", a);

// Loop infinito.
for ()
    print("Infinite...\n");

// Uso comum.
fn example (a:int, b:int) -> int {
    ret (a * b) + 31337;
}

// Concatena√ß√£o de fun√ß√µes.
fn primary (a:int, b:int) -> int {
    var value = 31337;

    fn secondary (a:int, b:int) -> int {
        ret (a * b) + value;
    }

    ret secondary(a, b);
}

// Fun√ß√µes anonimas.
print("Value: {}\n", 
    (fn (value :int) -> int { 
        ret value * 3; 
    })(31337)
);

// Fun√ß√£o sem retorno.
fn function () {
    print("Verbum\n");
}




// Interface comum...
interface FirstTemplate {
    pub fn getValues () -> array;
    pub fn getValues (index :int) -> int;
}

// Interface com heran√ßa.
interface ExampleTemplate extends FirstTemplate {
    pub fn checkString (string :string);
}

// Classe abstrata.
abstract AbstrationCommon {
    pro fn abstractMethod ();
}

// Classe.
class Common extends AbstractClass {
    // ...
    pub fn checkString (string :string) -> int { /* ... */ }

    // Implementa m√©todo abstrato.
    pro fn abstractMethod (){
        // ...
    }

    // Testa "parent" na classe herdeira.
    pub fn exampleA () -> str {
        ret "Verbum";
    }

    pub fn getExampleA () -> str {
        ret this.exampleA();
    }
}

// Classe com heran√ßa e implementa√ß√£o de interface.
final class Example extends Common implements ExampleTemplate {

    // Atributos.
    priv var attributeA :uint = 31337;
    pub var attributeB :string  = "Verbum üòÉ";
    pub static var subVersion :string = "1337";

    // Construtor.
    Example (a :uint, b :string) {
        this.attributeA = a;
        this.attributeB = b;
    }

    // M√©todo est√°tico.
    pub static fn getVersion () -> str {
        ret "1.0.0";
    }

    pub static fn getVersion (flag :bool) -> str {
        // if (flag)
        //     ret self::getVersion();
        // ret self::subVersion;
    }

    // Declara√ß√£o dos m√©todos e sobrecarga.
    pub fn getValues () -> array {
        ret [
            // this.attributeA,
            // this.attributeB
        ];
    }

    pub fn getValues (index :int) -> int {
        if (index == 1)
            // ret this.attributeA;
        ret -1;
    }

    // Sobrescreve m√©todo herdado (polimorfismo).
    final pro fn abstractMethod () {
        print("Verbum\n");
    }

    // Acessando uma implementa√ß√£o da classe base e n√£o da atual (parent).
    pub fn exampleA () -> str {
        ret "Divinus";
    }

    pub fn getExampleB () -> str {
        // ret parent::exampleA();
    }
}

// Instanciamento e uso.
var obj     :Example  = new Example(31337, "Verbum");
var resultA :array    = obj.getValues();
var resultB :int      = obj.getValues(1);
var resultC :int      = obj.checkString("Verbum Divinus");

print("Version: {}\n", Example::getVersion());
print("Sub version: {}\n", Example::subVersion);
print("ResultA = a: {}, b: {}\n", resultA[0], resultA[1]);
print("resultB = {}\n", resultB);
print("Check String = {}\n", resultC);

// Exemplo com "parent".
var obj1 = new Common();
obj1.exampleA();            // Verbum
obj1.getExampleA();         // Verbum

var obj2 = new Example();
obj2.exampleA();            // Divinus
obj2.getExampleA();         // Divinus
obj2.getExampleB();         // Verbum


var a = [];
var a = {};

ret [];
ret {};

var a = self.attr1;
var a = self::attr1;


ret self.attr1;
ret self::attr1;

var a = 10 * a.b;

var a = a.b();

var a = a::b();

var a = a();


class Example {
    priv var value :int = 0;

    pub fn foo (a :int) -> this {
        this.value += a;
        ret this;
    }

    pub fn bar (a :int) -> this {
        this.value += a;
        ret this;
    }

    pub fn show () {
        print("Value: {}\n", this.value);
    }
}

var obj = new Example();
obj.foo(10).show().bar(20).show();


// obj.setLogger(new class {
//     pub fn log (msg :string) {
//         print("{}\n", msg);
//     }
// });

// (new class {
//     pub fn show () {
//         print("Verbum\n");
//     }
// }).show();

// Clona objeto.
var objB :ClassName = clone(objA);

// Destr√≥i objeto.
destroy(objA);

// Serialization.
var stringObject :string = serialize(objA);
var objN :ClassName = unserialize(stringObject);

async fn http_get (link :string) -> string {
    ...
    ret response;
}

// Exemplo onde n√£o aguardamos o retorno final de http_get().
// Observe que o valor de 'response' ser√° modificado no futuro, e
// enquanto isso n√£o ocorre, seu valor continua como vazio.
var response = http_get('http://host/path');

for {
    if (response.size() <= 0)
        next;

    print("response: {}\n", response);
    break;
}

// Exemplo onde aguardamos o retorno de http_get().
var response = await http_get('http://host/path');

try {
    var response = await http_get('http://host/path');
} catch (err) {
    print("Error: {}\n", err);
}


var a = new Obj();

(new class {
    pub fn show () {
        print("Verbum\n");
    }
});

(new class {
    pub fn show () {
        print("Verbum\n");
    }
}).show();

class Name {
    
}

// obj.setLogger(new class {
//     pub fn log (msg :string) {
//         print("{}\n", msg);
//     }
// });


