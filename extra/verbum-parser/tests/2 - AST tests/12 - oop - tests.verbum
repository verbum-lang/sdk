// Classe com heranÃ§a e implementaÃ§Ã£o de interface.
final class Example extends Common implements ExampleTemplate {

    // Atributos.
    priv var attributeA :uint = 31337;
    pub var attributeB :string  = "Verbum ðŸ˜ƒ";
    pub static var subVersion :string = "1337";

    // Construtor.
    Example (a :uint, b :string) {
        this.attributeA = a;
        this.attributeB = b;
    }

    // MÃ©todo estÃ¡tico.
    pub static fn getVersion () -> str {
        ret "1.0.0";
    }

    pub static fn getVersion (flag :bool) -> str {
        if (flag)
            ret self::getVersion();
        ret self::subVersion;
    }

    // DeclaraÃ§Ã£o dos mÃ©todos e sobrecarga.
    pub fn getValues () -> array {
        ret [
            this.attributeA,
            this.attributeB
        ];
    }

    pub fn getValues (index :int) -> int {
        if (index == 1)
            ret this.attributeA;
        ret -1;
    }

    // Sobrescreve mÃ©todo herdado (polimorfismo).
    final pro fn abstractMethod () {
        print("Verbum\n");
    }

    // Acessando uma implementaÃ§Ã£o da classe base e nÃ£o da atual (parent).
    pub fn exampleA () -> str {
        ret "Divinus";
    }

    pub fn getExampleB () -> str {
        ret parent::exampleA();
    }
}


